---
layout: post
category: star
---

由于最近准备春招看到跨域的问题还是比较多的，打算深入学习一下写个专题。

# 目录

- [同源策略](#同源策略)
- [Ajax](#ajax)
	- [JSONP](#jsonp)
	- [WebSocket](#websocket)
	- [CORS](#cors)
	- [架设服务器代理](#架设服务器代理)

---

# [同源策略](#同源策略)

- [MDN文档-同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E5%90%8C%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89)
- [浏览器同源政策及其规避方法-阮一峰](https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)

## 源的定义

同源的定义非常简单，通俗的说，就是主机、端口和协议都是一样的。需要注意的是IE浏览器没有将端口作为判定是否同源的一部分。

## 源的继承

源的继承按照MDN文档叙述：
> 在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。

但是经我测试在chrome（版本：89.0.4389.90）中使用windows.open()打开about:blank并不会继承源。

![测试网页的源](/img/20210325/BMHzcfROMXaSo7JC.png)
<center>测试网页的源</center>

![about:blank的源](/img/20210325/kUK2uDBMLC52p3b0.png)
<center>调用windows.open(about:blank)后网页的源</center>

调用windows.open(/about:blank)会报错。

有趣的是在设置博客图片地址的时候，第一次显示不出来，发生了跨域的问题：

![图片显示不出来](/img/20210325/j3kRkSNWeNL0vm7q.png)
<center>图片显示不出来</center>

![发生了跨域问题](/img/20210325/PXO7SAQqAw06rsrU.png)
<center>发生了跨域问题</center>

之前按照一个网上教程先将图片传到github上然后引用绝对地址，但是这样会产生跨域问题；事实上只要引用一个相对地址就可以了。

## 源的修改

在某些条件下可以通过修改document.domain来修改域，但是只能设置为它的父域，同时当修改了domain之后，端口号将变成null,如果需要父域和子域之间进行通信，还需要在父域调用document.domain = document.domain，这样子域和父域的端口号都会变成null。

## 跨域权限

- 跨域的写操作一般是被允许的，例如链接、重定向和表单提交，这也就是csrf攻击的主要原理
- 跨域的资源嵌入一般是被允许的，但是很显然刚才我前面嵌入的图片是被chrome拦截了，这个应该也是存在安全风险的
- 跨域的读操作一般是不允许的

CSRF攻击能够成功，和浏览器cookie运作的方式是相关的，对于同一个域下面的url请求，浏览器会自动在请求头上面带上cookie，而不会验证这个请求是哪个网页发送的。所以黑客在拿不到cookie，也收不到服务器返回的报文的情况下开展了攻击。

目前，如果非同源，共有三种行为受到限制。

- Cookie、LocalStorage 和 IndexDB 无法读取。
- DOM 无法获得。
- AJAX 请求不能发送。

而跨域正是针对这三种限制采用相对应的解决方法。

---

# [Ajax](#ajax)

- [MDN文档-Ajax](https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX/Getting_Started)
- [MDN文档-Ajax接口](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)
- [ajax跨域，这应该是最全的解决方案了](https://segmentfault.com/a/1190000012469713)

## Ajax

Ajax简单来说就是异步js和xml的通信，而这个通信需要一个载体来封装对应的方法，这个载体对象就是XMLHttpRequest对象。

## Ajax具体流程

稍微梳理一下Ajax通信的流程和方法：

	1. var httpRequest = new XMLHttpRequest() //创建通信的对象
	2. httpRequest.onreadystatechange = function(){ ... } //绑定处理的函数
	3. httpRequest.open('GET', 'http://www.example.org/some.file', true); //调用http请求
	4. httpRequest. setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 设置消息类型
	5. httpRequest.send(); //发送请求
	6. if (httpRequest.readyState === XMLHttpRequest.DONE) { ... } //检查请求
	7. if (httpRequest.status === 200) {...}// 检查状态码
	8. httpRequest.responseText // 服务器以文本字符的形式返回
	9. httpRequest.responseXML //以 XMLDocument 对象方式返回，之后就可以使用JavaScript来处理

## Ajax常见报错信息

<table>
<tr>
<th>错误信息</th><th>状态码</th><th>错误原因</th><th>解决方案</th>
</tr>
<td rowspan="3">No 'Access-Control-Allow-Origin' header is present on the requested resource</td>
<td>404</td>
<td><ul><li>本次ajax请求是“非简单请求”,所以请求前会发送一次预检请求(OPTIONS)</li>
<li>服务器端后台接口没有允许OPTIONS请求,导致无法找到对应接口地址</li></ul></td>
<td>后端允许options请求</td>
<tr>
<td>405</td>
<td>后台方法允许OPTIONS请求,但是一些配置文件中(如安全配置),阻止了OPTIONS请求</td>
<td>后端关闭对应的安全配置</td>
</tr>
<tr>
<td>200</td>
<td>服务器端后台允许OPTIONS请求,并且接口也允许OPTIONS请求,但是头部匹配时出现不匹配现象</td>
<td>后端增加对应的头部支持</td>
</tr>
<tr>
<td>heade contains multiple values '*,*'</td>
<td>200</td>
<td>发生了重复配置</td>
<td>取消重复配置</td>
</tr>
</table>

## Ajax的跨域方案

目前针对Ajax跨域问题解决方案主要有四种：

- JSONP
- WebSocket
- CORS
- 架设服务器代理

## [JSONP](#jsonp)



## [CORS](#cors)



    


