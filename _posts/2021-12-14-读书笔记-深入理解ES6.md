---
layout: post
category: star
title: 读书笔记：深入理解ES6
---

## 目录

- [块级绑定](#块级绑定)
- [字符串与正则表达式](#字符串与正则表达式)
- [函数](#函数)

---

## 块级绑定

使用 let 或 const 声明的变量，在达到声明处之前都是无法访问的，试图访问会导致一个引用错误，即使在通常是安全的操作时(例如使用 typeof 运算符)，也是如此。

在使用 var 的情况下利用立即调用函数表达式 （IIFEs）来实现“块级作用域”的模拟实现：

```javascript
var funcs = [];
for (var i = 0; i < 10; i++) {
    funcs.push((function(value) {
        return function() {
            console.log(value);
				} 
    }(i)));
}
funcs.forEach(function(func) { 
  func(); // 从 0 到 9 依次输出
});
```

在常规的 for 循环当中，循环会在试图修改变量值的时候抛出错误：

```javascript
var funcs = [];
// 在一次迭代后抛出错误
for (const i = 0; i < 10; i++) {
    funcs.push(function() {
        console.log(i);
    }); 
}
```

但是在 for-in 和 for-of 循环中可以安全地使用 const 。

```javascript
var funcs = [],
    object = {
        a: true,
        b: true,
        c: true
    };

// 不会导致错误
for (const key in object) {
    funcs.push(function() {
        console.log(key);
    }); 
}

funcs.forEach(function(func) {
	func(); // 依次输出 "a"、 "b"、 "c"
});
```

当在全局作用域上使用 var 时，它会创建一个新的全局变量，并成为全局对象(在浏览器中是 window )的一 个属性。这意味着使用 var 可能会无意覆盖一个已有的全局属性，然而若你在全局作用域上使用 let 或 const ，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。

块级绑定的最佳实践是，在默认情况下使用 const，在知道变量需要更改的情况下使用 let。

---

## 字符串与正则表达式

在 ES6 之前， JS 的字符串以 16 位字符编码（UCS-2）为基础，每一个16位序列都是一个码元（code unit），用于表示一个字符。

Unicode 规定的全球唯一标识符称为代码点（code points），是从 0 开始的简单数字。

```javascript
var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(text.charAt(0));        // ""
console.log(text.charAt(1));        // ""
console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
```

在 UTF-16 使用单个 16 位码元的范围称为多语言基本平面（BMP），超出该范围的代码点不能用单个 16 位码元表示，而是会落在扩展平面内，UFT-16 引入代理对来解决这个问题，允许用两个 16 位码元来代表单个代码点。

在 ES6 中，为全面支持 UTF-16 新增方法是 codePointAt( ) ，它可以在给定字符串中按位置提取 Unicode 代码点：

```javascript
var text = "𠮷a";

console.log(text.charCodeAt(0));    // 55362
console.log(text.charCodeAt(1));    // 57271
console.log(text.charCodeAt(2));    // 97

console.log(text.codePointAt(0));   // 134071
console.log(text.codePointAt(1));   // 57271
console.log(text.codePointAt(2));   // 97
```

也可以根据该方法判断字符占一个码元还是两个码元：

```javascript
function is32Bit(c) {
    return c.codePointAt(0) > 0xFFFF;
}

console.log(is32Bit("𠮷"));         // true
console.log(is32Bit("a"));          // false
```

ES6 还提供了一个方法 fromCodePoint 从码元返回字符：

```javascript
console.log(String.fromCodePoint(134071));  //
```

### 正则表达式 u 标志

当一个正则表达式设置了 u 标志时，它的工作模式从针对码元转换为针对字符：

```javascript
var text = "𠮷";

console.log(text.length);           // 2
console.log(/^.$/.test(text));      // false
console.log(/^.$/u.test(text));     // tr
```

在不兼容 ES6 的 JS 引擎中使用 /u 会导致错误，所以可以通过一个函数验证是否支持 /u 写法：

```javascript
function hasRegExpU() {
    try {
        var pattern = new RegExp(".", "u");
        return true;
    } catch (ex) {
        return false;
    }
}
```

### 字符串的其他改动

includes( ) 方法，在给定文本存在于字符串中的任意位置时会返回 true ，否则返回 false 。

startsWith( ) 方法，在给定文本出现在字符串起始处时返回 true ，否则返回 false 。

endsWith( ) 方法，在给定文本出现在字符串结尾处时返回 true ，否则返回 false 。

repeat( ) 方法，它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串。

### 正则表达式的其他改动

```javascript
var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    // sticky 加上之后如果首字符不匹配那就跪了，底下改 lastIndex 就属于跪了
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

pattern.lastIndex = 1;
globalPattern.lastIndex = 1;
stickyPattern.lastIndex = 1;

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // Error! stickyResult is null
```

```javascript
var text = "hello1 hello2 hello3",
    pattern = /hello\d\s?/,
    result = pattern.exec(text),
    globalPattern = /hello\d\s?/g,
    globalResult = globalPattern.exec(text),
    stickyPattern = /hello\d\s?/y,
    stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello1 "
console.log(stickyResult[0]);   // "hello1 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 7
console.log(stickyPattern.lastIndex);   // 7

result = pattern.exec(text);
globalResult = globalPattern.exec(text);
stickyResult = stickyPattern.exec(text);

console.log(result[0]);         // "hello1 "
console.log(globalResult[0]);   // "hello2 "
console.log(stickyResult[0]);   // "hello2 "

console.log(pattern.lastIndex);         // 0
console.log(globalPattern.lastIndex);   // 14
console.log(stickyPattern.lastIndex);   // 14
```

只有调用正则表达式对象上的方法(例如 exec( ) 与 test( ) 方法)， lastIndex 属性才会生效。而将正则表达式作为参数传递给字符串上的方法(例如 match( ) )，并不会体现粘连特性。

ES6 增加了复制正则表达式的方法：

```javascript
var re1 = /ab/i,

    // throws an error in ES5, okay in ES6
    re2 = new RegExp(re1, "g");
```

ES6 增加了 flag 属性：

```javascript
var re = /ab/g;

console.log(re.source);     // "ab"
console.log(re.flags);      // "g"
```

### 模版字面量

使用模版字面量时缩进的影响非常大：

```javascript
let message = `Multiline
               string`;

console.log(message);           // "Multiline
                                //                 string"
console.log(message.length);    // 31
```

可以采用一种巧妙的方式:

```javascript
let html = `
<div>
    <h1>Title</h1>
</div>`.trim();
```

模版字面量的替换位由起始的 ${ 与结束的 } 来界定，其中允许放入任意的 JS 表达式。

模版字面量本身也是 JS 表达式，可以将模版表达式嵌套在模版表达式当中。

---

## 函数

使用 ES6 的默认参数时，只有当对应位置传入 undefined 时候才会采用默认参数：

```javascript
// uses default timeout
makeRequest("/foo", undefined, function(body) {
    doSomething(body);
});

// uses default timeout
makeRequest("/foo");

// doesn't use default timeout
makeRequest("/foo", null, function(body) {
    doSomething(body);
});
```

ES 6 下 arguments 严格反映传入参数的情况：

```javascript
// not in strict mode
function mixArgs(first, second = "b") {
    console.log(arguments.length); // 1
    console.log(first === arguments[0]); // true
    console.log(second === arguments[1]); // false
    first = "c";
    second = "d"
    console.log(first === arguments[0]); // false
    console.log(second === arguments[1]); // false
}

mixArgs("a");
```

在设定默认参数时，可以选择函数调用来替换字面量，也可以用之前的参数作为这个函数调用的默认参数：

```javascript
function getValue(value) {
    return value + 5;
}

function add(first, second = getValue(first)) {
    return first + second;
}

console.log(add(1, 1));     // 2
console.log(add(1));        // 7
```

### 剩余参数

