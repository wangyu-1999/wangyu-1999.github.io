---
layout: post
category: star
---

由于最近准备春招看到跨域的问题还是比较多的，打算深入学习一下写个专题。

# 目录

- [同源策略](#同源策略)
- [Ajax](#ajax)
- [CORS](#cors)
- [nginx代理](#nginx代理)

---

# [同源策略](#同源策略)

- [MDN文档-同源策略](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy#%E5%90%8C%E6%BA%90%E7%9A%84%E5%AE%9A%E4%B9%89)

## 源的定义

同源的定义非常简单，通俗的说，就是主机、端口和协议都是一样的。需要注意的是IE浏览器没有将端口作为判定是否同源的一部分。

## 源的继承

源的继承按照MDN文档叙述：
> 在页面中通过 about:blank 或 javascript: URL 执行的脚本会继承打开该 URL 的文档的源，因为这些类型的 URLs 没有包含源服务器的相关信息。

但是经我测试在chrome（版本：89.0.4389.90）中使用windows.open()打开about:blank并不会继承源。

测试网页的源：
![测试网页的源](/img/BMHzcfROMXaSo7JC.png)

调用windows.open(about:blank)后网页的源：
![about:blank的源](/img/kUK2uDBMLC52p3b0.png)

调用windows.open(/about:blank)会报错。

有趣的是在设置博客图片地址的时候，第一次显示不出来，发生了跨域的问题：
![图片显示不出来](/img/j3kRkSNWeNL0vm7q.png)
![发生了跨域问题](/img/PXO7SAQqAw06rsrU.png)

之前按照一个网上教程先将图片传到github上然后引用绝对地址，但是这样会产生跨域问题；事实上只要引用一个相对地址就可以了。

## 源的修改

在某些条件下可以通过修改document.domain来修改域，但是只能设置为它的父域，同时当修改了domain之后，端口号将变成null,如果需要父域和子域之间进行通信，还需要在父域调用document.domain = document.domain，这样子域和父域的端口号都会变成null。

## 跨域权限

- 跨域的写操作一般是被允许的，例如链接、重定向和表单提交，这也就是csrf攻击的主要原理
- 跨域的资源嵌入一般是被允许的，但是很显然刚才我前面嵌入的图片是被chrome拦截了，这个应该也是存在安全风险的
- 跨域的读操作一般是不允许的

CSRF攻击能够成功，和浏览器cookie运作的方式是相关的，对于同一个域下面的url请求，浏览器会自动在请求头上面带上cookie，而不会验证这个请求是哪个网页发送的。所以黑客在拿不到cookie，也收不到服务器返回的报文的情况下开展了攻击。

---

# [Ajax](#ajax)

- [MDN文档-Ajax](https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX/Getting_Started)
- [MDN文档-Ajax接口](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest)

## Ajax

Ajax简单来说就是异步js和xml的通信，而这个通信需要一个载体来封装对应的方法，这个载体对象就是XMLHttpRequest对象。

## Ajax具体流程

稍微梳理一下Ajax通信的流程和方法：

	1. var httpRequest = **new XMLHttpRequest**() //创建通信的对象
	2. httpRequest.**onreadystatechange** = function(){ ... } //绑定处理的函数
	3. httpRequest.**open**('GET', 'http://www.example.org/some.file', true); //调用http请求
	4. httpRequest. **setRequestHeader**('Content-Type', 'application/x-www-form-urlencoded'); // 设置消息类型
	5. httpRequest.**send**(); //发送请求
	6. if (httpRequest.**readyState** === XMLHttpRequest.DONE) { ... } //检查请求
	7. if (httpRequest.**status** === 200) {...}// 检查状态码
	8. httpRequest.**responseText** // 服务器以文本字符的形式返回
	9. httpRequest.**responseXML** //以 XMLDocument 对象方式返回，之后就可以使用JavaScript来处理

---

# [CORS](#cors)



    


